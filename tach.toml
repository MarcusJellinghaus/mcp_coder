# =============================================================================
# Tach Configuration - Architectural Boundary Enforcement
# =============================================================================
# Enforces architectural boundaries between modules to maintain clean architecture.
# Run with: tach check (or tools/tach_check.bat)
#
# Architecture follows Clean Architecture / Hexagonal principles:
# - Higher layers can depend on lower layers (not vice versa)
# - Domain logic is isolated from infrastructure concerns
# - Dependencies point inward toward the core
# =============================================================================

exclude = ["**/__pycache__", "build/", "dist/", ".venv/", "*.egg-info/"]
source_roots = ["src", "."]
exact = false
forbid_circular_dependencies = true
ignore_type_checking_imports = true

# =============================================================================
# Architectural Layers (top to bottom, highest to lowest)
# =============================================================================
# presentation  - User-facing interfaces (CLI, API endpoints)
# application   - Use cases, workflows, orchestration logic
# domain        - Core business logic, domain models, services
# infrastructure - Technical implementations (git, github, external services)
# foundation    - Shared constants, configuration, base utilities
# =============================================================================

layers = [
    "presentation",
    "application", 
    "domain",
    "infrastructure",
    "foundation"
]

# =============================================================================
# Layer 1: PRESENTATION
# =============================================================================
# Purpose: User-facing interfaces that handle input/output
# Rationale: CLI is the entry point - it can depend on anything below it
#            but nothing should depend on CLI (prevents coupling to UI)
# =============================================================================

[[modules]]
path = "mcp_coder.cli"
layer = "presentation"
# CLI is the top-level entry point that orchestrates user interactions.
# It imports from all layers below to compose functionality for users.
depends_on = [
    { path = "mcp_coder" },              # Root module exports for convenience
    { path = "mcp_coder.workflows" },     # High-level workflow orchestration
    { path = "mcp_coder.workflow_utils" }, # Workflow helper utilities
    { path = "mcp_coder.llm" },           # LLM interaction services
    { path = "mcp_coder.formatters" },    # Code formatting services
    { path = "mcp_coder.prompt_manager" }, # Prompt template management
    { path = "mcp_coder.utils" },         # General utilities
    { path = "mcp_coder.config" },        # Configuration management
    { path = "mcp_coder.constants" },     # Shared constants
    { path = "mcp_coder.mcp_code_checker" }, # MCP code checking tools
]

# =============================================================================
# Layer 2: APPLICATION
# =============================================================================
# Purpose: Use cases and workflow orchestration
# Rationale: Workflows coordinate domain services to fulfill user requirements.
#            They should not be imported by domain or infrastructure layers.
# =============================================================================

[[modules]]
path = "mcp_coder.workflows"
layer = "application"
# Workflows implement high-level use cases (implement, create_pr, etc.)
# They orchestrate domain services and utilities to complete tasks.
depends_on = [
    { path = "mcp_coder.workflow_utils" }, # Shared workflow helpers
    { path = "mcp_coder.llm" },           # LLM for code generation
    { path = "mcp_coder.formatters" },    # Code formatting after generation
    { path = "mcp_coder.prompt_manager" }, # Load workflow-specific prompts
    { path = "mcp_coder.utils" },         # Git, GitHub operations
    { path = "mcp_coder.config" },        # Access configuration
    { path = "mcp_coder.constants" },     # Shared constants
]

[[modules]]
path = "mcp_coder.workflow_utils"
layer = "application"
# Shared utilities specific to workflow execution (task tracking, progress, etc.)
# Separated from workflows to avoid circular dependencies between workflows.
depends_on = [
    { path = "mcp_coder.llm" },           # LLM interaction for task analysis
    { path = "mcp_coder.formatters" },    # Format workflow outputs
    { path = "mcp_coder.prompt_manager" }, # Prompt management
    { path = "mcp_coder.utils" },         # General utilities
    { path = "mcp_coder.config" },        # Configuration access
    { path = "mcp_coder.constants" },     # Shared constants
]

# =============================================================================
# Layer 3: DOMAIN
# =============================================================================
# Purpose: Core business logic and domain services
# Rationale: Domain services encapsulate core functionality (LLM, formatting).
#            They should be independent of how they're invoked (CLI, API, etc.)
# =============================================================================

[[modules]]
path = "mcp_coder.llm"
layer = "domain"
# LLM service handles all AI/Claude interactions.
# Core domain service that should be reusable across different interfaces.
# Depends on utils only for subprocess execution (running claude CLI).
depends_on = [
    { path = "mcp_coder.utils" },     # subprocess_runner for CLI execution
    { path = "mcp_coder.config" },    # LLM configuration (API keys, models)
    { path = "mcp_coder.constants" }, # LLM-related constants
]

[[modules]]
path = "mcp_coder.formatters"
layer = "domain"
# Code formatting service (black, isort integration).
# Pure domain service with no external dependencies beyond config.
depends_on = [
    { path = "mcp_coder.utils" },     # File system utilities if needed
    { path = "mcp_coder.config" },    # Formatter configuration
    { path = "mcp_coder.constants" }, # Formatting constants
]

[[modules]]
path = "mcp_coder.prompt_manager"
layer = "domain"
# Prompt template management service.
# Loads and parses prompt templates from markdown files.
# Pure domain logic - no infrastructure dependencies.
depends_on = [
    { path = "mcp_coder.utils" },     # File reading utilities
    { path = "mcp_coder.config" },    # Prompt file paths configuration
    { path = "mcp_coder.constants" }, # Default prompt paths
]

# =============================================================================
# Layer 4: INFRASTRUCTURE  
# =============================================================================
# Purpose: Technical implementations and external service integrations
# Rationale: Infrastructure provides technical capabilities (git, github, etc.)
#            that domain services use. Should not contain business logic.
# =============================================================================

[[modules]]
path = "mcp_coder.utils"
layer = "infrastructure"
# General infrastructure utilities: git operations, github API, subprocess runner.
# These are technical implementations that support domain and application layers.
# Note: __init__.py re-exports from submodules but these are not architectural deps.
depends_on = [
    { path = "mcp_coder.config" },    # Access configuration for git/github
    { path = "mcp_coder.constants" }, # Shared constants
]

# -----------------------------------------------------------------------------
# Utils Submodule Independence Rules
# -----------------------------------------------------------------------------
# Enforces that git, github, and jenkins operations remain properly layered:
# - git_operations: independent (no deps on github/jenkins)
# - github_operations: can depend on git_operations (needs branch info)
# - jenkins_operations: independent (no deps on git/github)
# -----------------------------------------------------------------------------

[[modules]]
path = "mcp_coder.utils.git_operations"
layer = "infrastructure"
# Git operations: branches, commits, diffs, remotes, staging.
# Independent module - should NOT depend on github or jenkins.
depends_on = [
    { path = "mcp_coder.utils" },     # Base utils (subprocess_runner, log_utils)
    { path = "mcp_coder.config" },    # Git configuration
    { path = "mcp_coder.constants" }, # Git-related constants
]

[[modules]]
path = "mcp_coder.utils.github_operations"
layer = "infrastructure"
# GitHub API operations: issues, PRs, labels, CI status.
# Can depend on git_operations for branch validation and issue number extraction.
depends_on = [
    { path = "mcp_coder.utils.git_operations" }, # Branch info, issue number extraction
    { path = "mcp_coder.utils" },     # Base utils (log_utils, user_config)
    { path = "mcp_coder.config" },    # GitHub API configuration
    { path = "mcp_coder.constants" }, # GitHub-related constants
]

[[modules]]
path = "mcp_coder.utils.jenkins_operations"
layer = "infrastructure"
# Jenkins CI/CD operations: job status, queue management.
# Independent module - should NOT depend on git or github.
depends_on = [
    { path = "mcp_coder.utils" },     # Base utils (log_utils, user_config)
    { path = "mcp_coder.config" },    # Jenkins configuration
    { path = "mcp_coder.constants" }, # Jenkins-related constants
]

[[modules]]
path = "mcp_coder.mcp_code_checker"
layer = "infrastructure"
# MCP code checking tool implementation.
# Infrastructure service for running code quality checks.
# Standalone module with no internal dependencies (uses only stdlib).
depends_on = [
    { path = "mcp_coder.config" },    # Checker configuration
    { path = "mcp_coder.constants" }, # Check-related constants
]

# =============================================================================
# Layer 5: FOUNDATION
# =============================================================================
# Purpose: Shared constants, configuration, and base definitions
# Rationale: Foundation modules have no dependencies on other internal modules.
#            They provide the base that all other modules build upon.
# =============================================================================

[[modules]]
path = "mcp_coder.config"
layer = "foundation"
# Configuration management for the entire application.
# Must have no internal dependencies - it's the foundation everything builds on.
# If config needs utilities, those utilities must also be in foundation.
depends_on = []

[[modules]]
path = "mcp_coder.constants"
layer = "foundation"
# Shared constants used across the application.
# No dependencies - pure value definitions.
depends_on = []

# =============================================================================
# ROOT MODULE
# =============================================================================
# Purpose: Package entry point and public API exports
# Rationale: The root __init__.py re-exports key functionality for external use.
#            It imports from domain layer to expose a clean public API.
# =============================================================================

[[modules]]
path = "mcp_coder"
# Root module exports public API: ask_llm, get_prompt, utilities.
# Consumers import from mcp_coder directly rather than deep paths.
# Note: __init__.py re-exports from submodules but tach tracks actual source.
depends_on = [
    { path = "mcp_coder.llm" },           # Export LLM functionality
    { path = "mcp_coder.utils" },         # Export utility functions
    { path = "mcp_coder.prompt_manager" }, # Export prompt management
]


# =============================================================================
# FUTURE RULES (commented out - create issues to fix violations)
# =============================================================================
# These rules would enforce stricter boundaries but currently have violations.
# Each commented rule includes the reason and suggested fix.
# =============================================================================

# -----------------------------------------------------------------------------
# REFACTORING: Split utils into separate top-level modules
# -----------------------------------------------------------------------------
# Current: mcp_coder.utils contains git_operations, github_operations, 
#          jenkins_operations as submodules plus generic utilities.
#
# Proposed: Move to top-level modules for clearer architecture:
#   - mcp_coder.git (from utils/git_operations)
#   - mcp_coder.github (from utils/github_operations)  
#   - mcp_coder.jenkins (from utils/jenkins_operations)
#   - mcp_coder.utils (keep generic utilities: subprocess_runner, log_utils, etc.)
#
# Benefits:
#   - Clearer dependency hierarchy (github depends on git, not circular)
#   - Better testability (mock external services independently)
#   - Cleaner imports (from mcp_coder.github import IssueManager)
#   - Enforces that github can depend on git, but not vice versa
#
# Dependencies after refactoring:
#   - utils: foundation utilities (subprocess_runner, log_utils, user_config)
#   - git: depends on utils (for subprocess execution)
#   - github: depends on utils AND git (needs git branch info)
#   - jenkins: depends on utils (for config and logging)
#
# Files to update when refactoring:
#   - src/mcp_coder/__init__.py (update re-exports)
#   - src/mcp_coder/utils/__init__.py (remove git/github/jenkins exports)
#   - All files importing from utils.git_operations, utils.github_operations, etc.
#   - See: grep -r "from.*utils.git_operations" src/
#   - See: grep -r "from.*utils.github_operations" src/
#   - See: grep -r "from.*utils.jenkins_operations" src/
# -----------------------------------------------------------------------------

# [[modules]]
# path = "mcp_coder.git"
# layer = "infrastructure"
# # Git operations: branch management, commits, diffs, remotes, staging.
# # Core version control infrastructure used by github module and workflows.
# depends_on = [
#     { path = "mcp_coder.utils" },     # subprocess_runner for git commands
#     { path = "mcp_coder.config" },    # Git configuration
#     { path = "mcp_coder.constants" }, # Git-related constants
# ]

# [[modules]]
# path = "mcp_coder.github"
# layer = "infrastructure"
# # GitHub API operations: issues, PRs, labels, CI status.
# # External service integration that depends on git for branch info.
# depends_on = [
#     { path = "mcp_coder.git" },       # Branch validation, issue number extraction
#     { path = "mcp_coder.utils" },     # log_utils, user_config
#     { path = "mcp_coder.config" },    # GitHub API configuration
#     { path = "mcp_coder.constants" }, # GitHub-related constants
# ]

# [[modules]]
# path = "mcp_coder.jenkins"
# layer = "infrastructure"
# # Jenkins CI/CD operations: job status, queue management.
# # External service integration, independent of git/github.
# depends_on = [
#     { path = "mcp_coder.utils" },     # log_utils, user_config
#     { path = "mcp_coder.config" },    # Jenkins configuration
#     { path = "mcp_coder.constants" }, # Jenkins-related constants
# ]

# -----------------------------------------------------------------------------
# RULE: LLM providers should only depend on LLM types (not utils)
# -----------------------------------------------------------------------------
# Why: Provider implementations should be isolated from infrastructure.
#      This would make providers more portable and testable.
# Violations: claude_code_cli.py imports subprocess_runner from utils
# Fix: Move subprocess_runner to a shared low-level module or into llm
# Status: Requires refactoring subprocess handling
# -----------------------------------------------------------------------------
# [[modules]]
# path = "mcp_coder.llm.providers"
# layer = "domain"
# depends_on = [
#     { path = "mcp_coder.llm.types" },
#     { path = "mcp_coder.config" },
#     { path = "mcp_coder.constants" },
# ]

# -----------------------------------------------------------------------------
# RULE: Workflows should not directly import from utils.git_operations
# -----------------------------------------------------------------------------
# Why: Workflows should use a higher-level abstraction rather than
#      reaching into infrastructure details.
# Violations: workflows/implement imports git_operations directly
# Fix: Create application-level git service in workflow_utils
# Status: Needs architectural discussion
# -----------------------------------------------------------------------------
# [[modules]]
# path = "mcp_coder.workflows"
# layer = "application"
# strict_depends_on = [
#     { path = "mcp_coder.workflow_utils" },
#     { path = "mcp_coder.llm" },
#     { path = "mcp_coder.formatters" },
#     { path = "mcp_coder.prompt_manager" },
#     # Intentionally NOT including mcp_coder.utils directly
# ]


# =============================================================================
# TEST MODULE RULES
# =============================================================================
# These rules enforce that test modules only import from their target modules
# and shared test utilities. This ensures:
# - Unit tests are focused on testing one module
# - Test isolation (test modules don't depend on each other)
# - Clear test boundaries matching source architecture
# =============================================================================

# -----------------------------------------------------------------------------
# Test layer definition
# -----------------------------------------------------------------------------
# Tests sit above all source modules - they can import from any source module
# but source modules should never import from tests.
# -----------------------------------------------------------------------------

[[modules]]
path = "tests"
# Root test module - shared fixtures and utilities via conftest.py
# Can import from any mcp_coder module for testing purposes.
depends_on = [
    { path = "mcp_coder" },
    { path = "mcp_coder.cli" },
    { path = "mcp_coder.workflows" },
    { path = "mcp_coder.workflow_utils" },
    { path = "mcp_coder.llm" },
    { path = "mcp_coder.formatters" },
    { path = "mcp_coder.prompt_manager" },
    { path = "mcp_coder.utils" },
    { path = "mcp_coder.utils.git_operations" },
    { path = "mcp_coder.utils.github_operations" },
    { path = "mcp_coder.utils.jenkins_operations" },
    { path = "mcp_coder.config" },
    { path = "mcp_coder.constants" },
    { path = "mcp_coder.mcp_code_checker" },
]

# -----------------------------------------------------------------------------
# RULE: Test modules should only import their target module
# -----------------------------------------------------------------------------
# Why: Unit tests should be focused on testing one module at a time.
#      This makes tests more maintainable and failures easier to diagnose.
#
# Note: These rules are commented out because they would require significant
#       test refactoring. Enable gradually as tests are cleaned up.
# -----------------------------------------------------------------------------

# [[modules]]
# path = "tests.cli"
# # CLI tests should only import CLI module and test utilities
# depends_on = [
#     { path = "tests" },                  # Shared fixtures
#     { path = "mcp_coder.cli" },          # Module under test
#     { path = "mcp_coder.config" },       # Configuration for test setup
#     { path = "mcp_coder.constants" },    # Constants for assertions
# ]

# [[modules]]
# path = "tests.llm"
# # LLM tests should only import LLM module and test utilities
# depends_on = [
#     { path = "tests" },                  # Shared fixtures
#     { path = "mcp_coder.llm" },          # Module under test
#     { path = "mcp_coder.config" },       # Configuration for test setup
#     { path = "mcp_coder.constants" },    # Constants for assertions
# ]

# [[modules]]
# path = "tests.utils"
# # Utils tests should only import utils module and test utilities
# depends_on = [
#     { path = "tests" },                  # Shared fixtures
#     { path = "mcp_coder.utils" },        # Module under test
#     { path = "mcp_coder.config" },       # Configuration for test setup
#     { path = "mcp_coder.constants" },    # Constants for assertions
# ]

# [[modules]]
# path = "tests.workflows"
# # Workflow tests should only import workflows module and test utilities
# depends_on = [
#     { path = "tests" },                  # Shared fixtures
#     { path = "mcp_coder.workflows" },    # Module under test
#     { path = "mcp_coder.workflow_utils" }, # Related workflow utilities
#     { path = "mcp_coder.config" },       # Configuration for test setup
#     { path = "mcp_coder.constants" },    # Constants for assertions
# ]

# [[modules]]
# path = "tests.formatters"
# # Formatter tests should only import formatters module and test utilities
# depends_on = [
#     { path = "tests" },                  # Shared fixtures
#     { path = "mcp_coder.formatters" },   # Module under test
#     { path = "mcp_coder.config" },       # Configuration for test setup
#     { path = "mcp_coder.constants" },    # Constants for assertions
# ]
